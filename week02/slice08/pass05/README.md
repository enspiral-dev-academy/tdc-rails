# Encrypting our passwords

To encrypt our password we need a one-way encryption algorithm. One way means we can encrypt it, but we can't decrypt it. That is the most secure way.

Now you might ask, How are we going to authenticate a user if we can't decrypt her password?

Simple. We won't decrypt it. We'll encrypt the new password and compare the encrypted "digests". Clever, eh?

We need a good algorithm. One of the best is the Blowfish algorithm, also called SHA. There is a library that handles this for us called BCrypt. We can install the bcrypt gem to make it available to us:

In our Gemfile:

```ruby
gem 'bcrypt', '~> 3.1.7'
```

Don't forget to run `bundle` to install it.

Then in our User model (`app/models/user.rb`), we can require 'bcrypt':

```ruby
require 'bcrypt'
```

Now we're ready to encrypt. Let's add a test to our model spec. First we'll need to redo our FactoryGirl user model so that it takes password and password_confirmation fields:

```ruby
# in spec/factories/users.rb
FactoryGirl.define do
  factory :user do
    email { Faker::Internet.email }
    password { Faker::Internet.password }
    password_confirmation { |u| u.password }
  end
end
```
For the password_confirmation field, we pass a block that takes the new User. Then we can use the new User params to set the confirmation equal to the password that was generated by Faker.

Next we'll need to rewrite our `spec/models/user_spec.rb` to use the new factory:

```ruby
require 'rails_helper'

RSpec.describe User, type: :model do
  it "is invalid without an email" do
    user = build(:user, :email => nil)

    expect(user).not_to be_valid
  end

  it "is invalid without an password" do
    user = build(:user, :password => nil)

    expect(user).not_to be_valid
  end

  it "finds and authenticates a user" do
    attrs = attributes_for(:user)
    user = create(:user, attrs)

    expect(User.authenticate(attrs.email, attrs.password)).to be_truthy
    expect(User.authenticate(attrs.email, "")).to be_falsy
    expect(User.authenticate("", attrs.password)).to be_falsy
  end

  it "authenticates a user" do
    attrs = attributes_for(:user)
    user = create(:user, attrs)

    expect(user.authenticate(attrs.password)).to eq(true)
    expect(user.authenticate("")).to eq(false)
  end
end
```

Creating a new user is a two-step process now. First we use FactoryGirl to generate the attributes which we store in a variable called `attrs`. Then we create the actual user with those attrs. This way we have access to the password that was generated in `attrs` whereas the new `user` object has the digest.

When we try to run this, we find that the User model also needs changing. In the future, we don't need to do all these extra steps. We can just build our model with the encrypted password from the getgo.


